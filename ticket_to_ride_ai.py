# -*- coding: utf-8 -*-
"""Ticket_To_Ride_AI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xeuYIXfIWVHir8u3D_LM1K9gck9uJSR6

**Sheldon Slater** </p>
**810865586**</p>
**TICKET TO RIDE AI**</p>
**Monte Carlo Tree Search**
"""

import itertools
import random
import math
import copy
import json
import pickle
import _pickle as cPickle

#from google.colab import drive
#drive.mount('/content/drive')

"""**Class Implementation**"""

class RailLine:
   def __init__(self,station_one,station_two, cost, color,color_extra):
      self.station_one = station_one
      self.station_two = station_two
      self.cost = cost
      self.color = color
      self.color_extra = color_extra
      self.connections = []
      self.owner =  0
      self.ownercolor = 'X'
      self.owner_second = 0
      self.owner_second_color = 'X'
   def get_name(self):
     return self.station_one+self.station_two
   def p_name(self):
      print(self.station_one,'-',self.station_two)
   def print_information(self):
     print("___________________________________________________________________________________________________________________________________________")
     print("Train Line")
     self.p_name()
     print("___________________________________________________________________________________________________________________________________________")
     print("Owned By: ",self.owner)
     if self.owner_second != 'X':
       print("Second Owner: ",self.owner_second)

class Destintation_Ticket:
  def __init__(self,station_one,station_two,reward):
    self.station_one = station_one
    self.station_two = station_two
    self.reward = reward
  def p_info(self):
    print(self.station_one,'-',self.station_two,':',self.reward)

class Player:
  def __init__(self,playerID):
    self.ID = playerID
    self.destination_tickets = []
    self.train_carts = 45
    self.wild_cards = 0
    self.white_cards = 0
    self.black_cards = 0
    self.blue_cards = 0
    self.yellow_cards = 0
    self.pink_cards = 0
    self.orange_cards = 0
    self.red_cards = 0
    self.green_cards = 0
  def Cards_Remaining(self):
    return self.wild_cards+self.white_cards+self.black_cards+self.blue_cards+self.yellow_cards+self.pink_cards+self.orange_cards+self.red_cards+self.green_cards

  def print_inventory(self):
    print("Player Inventory:")
    print("___________________________________________________________________________________________________________________________________________")
    print("wild: ",self.wild_cards,", white: ",self.white_cards,", black: ",self.black_cards,", blue: ",self.blue_cards,", yellow: ",self.yellow_cards)
    print("pink: ", self.pink_cards, ", orange: ", self.orange_cards, ", red: ",self.red_cards,", green: ",self.green_cards)
    print("train carts remaining: ", self.train_carts)
    print("___________________________________________________________________________________________________________________________________________")
    print("Destination Tickets:")
    for destination in self.destination_tickets:
      destination.p_info()
    print("___________________________________________________________________________________________________________________________________________")
  def Check_Affordability(self,line):
  #Checks whether a player is able able to afford a rail line
    available_funds = 0
    if self.train_carts < line.cost: return False

    c1,c2 = Check_Available_Colors(line)
    if   (c1 == 'G')|(c2 == 'G'):available_funds = self.wild_cards+self.white_cards+self.black_cards+self.blue_cards+self.yellow_cards+self.pink_cards+self.orange_cards+self.red_cards+self.green_cards
    elif (c1 == 'W')|(c2 == 'W'):available_funds = self.wild_cards+self.white_cards
    elif (c1 == 'B')|(c2 == 'B'):available_funds = self.wild_cards+self.black_cards
    elif (c1 == 'U')|(c2 == 'U'):available_funds = self.wild_cards+self.blue_cards
    elif (c1 == 'Y')|(c2 == 'Y'):available_funds = self.wild_cards+self.yellow_cards
    elif (c1 == 'P')|(c2 == 'P'):available_funds = self.wild_cards+self.pink_cards
    elif (c1 == 'O')|(c2 == 'O'):available_funds = self.wild_cards+self.orange_cards
    elif (c1 == 'R')|(c2 == 'R'):available_funds = self.wild_cards+self.red_cards
    elif (c1 == 'E')|(c2 == 'E'):available_funds = self.wild_cards+self.green_cards

    if available_funds >= line.cost:
      return True
    else: return False

  def Purchase_Rail_Line(self,line,deck):
  #Removes Cards from player in order to pay for a rail line
    self.train_carts-=line.cost
    c1,c2 = Check_Available_Colors(line)
    if   (c1 == 'G')|(c2 == 'G'):
      self.randomly_pay(line.cost,deck)
      return 'G'
    elif (c1 == 'W')|(c2 == 'W'):
      self.pay_with_colors('W',line.cost,deck)
      return 'W'
    elif (c1 == 'B')|(c2 == 'B'):
      self.pay_with_colors('B',line.cost,deck)
      return 'B'
    elif (c1 == 'U')|(c2 == 'U'):
      self.pay_with_colors('U',line.cost,deck)
      return 'U'
    elif (c1 == 'Y')|(c2 == 'Y'):
      self.pay_with_colors('Y',line.cost,deck)
      return 'Y'
    elif (c1 == 'P')|(c2 == 'P'):
      self.pay_with_colors('P',line.cost,deck)
      return 'P'
    elif (c1 == 'O')|(c2 == 'O'):
      self.pay_with_colors('O',line.cost,deck)
      return 'O'
    elif (c1 == 'R')|(c2 == 'R'):
      self.pay_with_colors('R',line.cost,deck)
      return 'R'
    elif (c1 == 'E')|(c2 == 'E'):
      self.pay_with_colors('E',line.cost,deck)
      return 'E'
  
  def gather_cards(self):
  #Places cards into an array for random access
    cards = [0,0,0,0,0,0,0,0]
    cards[0] = self.white_cards
    cards[1] = self.black_cards
    cards[2] = self.blue_cards
    cards[3] = self.yellow_cards
    cards[4] = self.pink_cards
    cards[5] = self.orange_cards
    cards[6] = self.red_cards
    cards[7] = self.green_cards
    return cards
  

  def pay_with_colors(self,color,cost,deck):
  #Removes Matching Color Cards from the players inventory equal to the cost
  #If no more colors remain, then remove wild cards to pay for the rest
     spent = cost
     if color == 'W':
       while((spent > 0)&(self.white_cards>0)):
         self.white_cards-=1
         deck.white_cards+=1
         spent-=1
     elif color == 'B':
       while((spent > 0)&(self.black_cards>0)):
         self.black_cards-=1
         deck.black_cards+=1
         spent-=1
     elif color == 'U':
       while((spent > 0)&(self.blue_cards>0)):
         self.blue_cards-=1
         deck.blue_cards+=1
         spent-=1
     elif color == 'Y':
       while((spent > 0)&(self.yellow_cards>0)):
         self.yellow_cards-=1
         deck.yellow_cards+=1
         spent-=1
     elif color == 'P':
       while((spent > 0)&(self.pink_cards>0)):
         self.pink_cards-=1
         deck.pink_cards+=1
         spent-=1
     elif color == 'O':
       while((spent > 0)&(self.orange_cards>0)):
         self.orange_cards-=1
         deck.orange_cards+=1
         spent-=1
     elif color == 'R':
       while((spent > 0)&(self.red_cards>0)):
         self.red_cards-=1
         deck.red_cards+=1
         spent-=1
     elif color == 'E':
       while((spent > 0)&(self.green_cards>0)):
         self.green_cards-=1
         deck.green_cards+=1
         spent-=1

     if(spent>0):
       while(spent > 0):
         self.wild_cards-=1
         deck.wild_cards+=1
         spent-=1     


  def randomly_pay(self,cost,deck):
  #randomly removes cards to pay for a 'grey' rail line
  #removes wildcards last
    cards = self.gather_cards()
    spent = cost
    while ((spent > 0) & (sum(cards) > 0)):
      rand = random.randint(0,7)
      if(cards[rand]>0):
        cards[rand]-=1
        if   rand == 0:
          self.white_cards-=1
          deck.white_cards+=1
        elif rand == 1:
          self.black_cards-=1
          deck.black_cards+=1
        elif rand == 2: 
          self.blue_cards-=1
          deck.blue_cards+=1
        elif rand == 3:
          self.yellow_cards-=1
          deck.yellow_cards+=1
        elif rand == 4:
          self.pink_cards-=1
          deck.pink_cards+=1
        elif rand == 5:
          self.orange_cards-=1
          deck.orange_cards+=1
        elif rand == 6:
          self.red_cards-=1
          deck.red_cards+=1
        elif rand == 7:
          self.green_cards-=1
          deck.green_cards+=1
        spent-=1
      
    if spent>0:
      while(spent > 0):
        self.wild_cards-=1
        deck.wild_cards+=1
        spent-=1

class FaceUp_Card_Pile:
  def __init__(self):
    self.wild_cards = 0
    self.white_cards = 0
    self.black_cards = 0
    self.blue_cards = 0
    self.yellow_cards = 0
    self.pink_cards = 0
    self.orange_cards = 0
    self.red_cards = 0
    self.green_cards = 0

  def print_faceUp_cards(self):
    print("wild: ",self.wild_cards,", white: ",self.white_cards,", black: ",self.black_cards,", blue: ",self.blue_cards,", yellow: ",self.yellow_cards)
    print("pink: ", self.pink_cards, ", orange: ", self.orange_cards, ", red: ",self.red_cards,", green: ",self.green_cards)

  def Replace_Cards(self,deck):
    cardfound = False
    if deck.Cards_Remaining() > 0:
      while(cardfound == False):
        rand = random.randint(0,8)
        if(rand == 0)&(deck.wild_cards>0):
          deck.wild_cards-=1
          self.wild_cards+=1
          cardfound = True
        elif(rand == 1)&(deck.white_cards>0):
          deck.white_cards-=1
          self.white_cards+=1
          cardfound = True
        elif(rand == 2)&(deck.black_cards>0):
          deck.black_cards-=1
          self.black_cards+=1
          cardfound = True
        elif(rand == 3)&(deck.blue_cards>0):
          deck.blue_cards-=1
          self.blue_cards+=1
          cardfound = True
        elif(rand == 4)&(deck.yellow_cards>0):
          deck.yellow_cards-=1
          self.yellow_cards+=1
          cardfound = True
        elif(rand == 5)&(deck.pink_cards>0):
          deck.pink_cards-=1
          self.pink_cards+=1
          cardfound = True
        elif(rand == 6)&(deck.orange_cards>0):
          deck.orange_cards-=1
          self.orange_cards+=1
          cardfound = True
        elif(rand == 7)&(deck.red_cards>0):
          deck.red_cards-=1
          self.red_cards+=1
          cardfound = True
        elif(rand == 8)&(deck.green_cards>0):
          deck.green_cards-=1
          self.green_cards+=1
          cardfound = True 


class Train_Card_Deck:
  def __init__(self):
    self.wild_cards = 14
    self.white_cards = 12
    self.black_cards = 12
    self.blue_cards = 12
    self.yellow_cards = 12
    self.pink_cards = 12
    self.orange_cards = 12
    self.red_cards = 12
    self.green_cards = 12

  def Draw_Card(self,player):
    cardfound = False
    if self.Cards_Remaining() > 0:
      while(cardfound == False):
        rand = random.randint(0,8)
        if(rand == 0)&(self.wild_cards>0):
          self.wild_cards-=1
          player.wild_cards+=1
          cardfound = True
        elif(rand == 1)&(self.white_cards>0):
          self.white_cards-=1
          player.white_cards+=1
          cardfound = True
        elif(rand == 2)&(self.black_cards>0):
          self.black_cards-=1
          player.black_cards+=1
          cardfound = True
        elif(rand == 3)&(self.blue_cards>0):
          self.blue_cards-=1
          player.blue_cards+=1
          cardfound = True
        elif(rand == 4)&(self.yellow_cards>0):
          self.yellow_cards-=1
          player.yellow_cards+=1
          cardfound = True
        elif(rand == 5)&(self.pink_cards>0):
          self.pink_cards-=1
          player.pink_cards+=1
          cardfound = True
        elif(rand == 6)&(self.orange_cards>0):
          self.orange_cards-=1
          player.orange_cards+=1
          cardfound = True
        elif(rand == 7)&(self.red_cards>0):
          self.red_cards-=1
          player.red_cards+=1
          cardfound = True
        elif(rand == 8)&(self.green_cards>0):
          self.green_cards-=1
          player.green_cards+=1
          cardfound = True 

  def Cards_Remaining(self):
    return self.wild_cards+self.white_cards+self.black_cards+self.blue_cards+self.yellow_cards+self.pink_cards+self.orange_cards+self.red_cards+self.green_cards
  def Print_Cards_in_Deck(self):
    print("wild: ",self.wild_cards,", white: ",self.white_cards,", black: ",self.black_cards,", blue: ",self.blue_cards,", yellow: ",self.yellow_cards)
    print("pink: ", self.pink_cards, ", orange: ", self.orange_cards, ", red: ",self.red_cards,", green: ",self.green_cards)

class game_node_class():
  def __init__(self,player_1,player_2,train_routes,face_up_cards,deck,destination_ticket_deck,parent_node):
    self.player_1 = player_1
    self.player_2 = player_2
    self.train_routes = train_routes
    self.face_up_cards = face_up_cards
    self.deck = deck
    self.destination_ticket_deck = destination_ticket_deck
    self.wins = 0
    self.visits = 0
    self.child_nodes = []
    self.parent_node = parent_node 

  def Print_Game_Info(self):
    print("###########################################################################################################################################")
    print("PLAYER 1:")
    self.player_1.print_inventory()
    print("Owned Routes:")
    for route in self.train_routes:
      if (route.owner == self.player_1.ID)|(route.owner_second== self.player_1.ID):
        route.p_name()
    print("___________________________________________________________________________________________________________________________________________")
    print("###########################################################################################################################################")
    print("PLAYER 2:")
    self.player_2.print_inventory()
    print("Owned Routes:")
    for route in self.train_routes:
      if (route.owner == self.player_2.ID)|(route.owner_second== self.player_2.ID):
        route.p_name()
    print("___________________________________________________________________________________________________________________________________________")
    print("###########################################################################################################################################")

def Game_Positions_Swap(game_node):
  new_game_node = game_node_class(game_node.player_2,game_node.player_1,game_node.train_routes,game_node.face_up_cards,game_node.deck,game_node.destination_ticket_deck,game_node.parent_node)

  for line in new_game_node.train_routes:
    if line.owner == game_node.player_1.ID:
      line.owner = game_node.player_2.ID
    elif line.owner == game_node.player_2.ID:
      line.owner = game_node.player_1.ID
    if line.owner_second == game_node.player_1.ID:
      line.owner_second = game_node.player_2.ID
    elif line.owner_second == game_node.player_2.ID:
      line.owner_second = game_node.player_1.ID
  new_game_node.player_1.ID = 1
  new_game_node.player_2.ID = 2
  return new_game_node

"""**Apply Moves Functions**"""

def Apply_Build_Line(player,rail_line,card_deck):
  line_color = player.Purchase_Rail_Line(rail_line,card_deck)
  if rail_line.owner == 0:
    rail_line.owner = player.ID
    if line_color == rail_line.color:
      rail_line.ownercolor = rail_line.color
      rail_line.owner_second_color = rail_line.color_extra
    else:
      rail_line.ownercolor = rail_line.color_extra
      rail_line.owner_second_color = rail_line.color
  else:
    rail_line.owner_second = player.ID

def Apply_Draw_Wildcard(player,faceUp_cardPile,card_deck):
  player.wild_cards+=1
  faceUp_cardPile.wild_cards-=1
  faceUp_cardPile.Replace_Cards(card_deck)

def Apply_Pick_From_FaceUp_Pile(player,selection,faceUp_cardPile,card_deck):
  for choice in selection:
     if   choice == 'W':
       player.white_cards+=1
       faceUp_cardPile.white_cards-=1
       faceUp_cardPile.Replace_Cards(card_deck)
     elif choice == 'B':
       player.black_cards+=1
       faceUp_cardPile.black_cards-=1
       faceUp_cardPile.Replace_Cards(card_deck)
     elif choice == 'U':
       player.blue_cards+=1
       faceUp_cardPile.blue_cards-=1
       faceUp_cardPile.Replace_Cards(card_deck)
     elif choice == 'Y':
       player.yellow_cards+=1
       faceUp_cardPile.yellow_cards-=1
       faceUp_cardPile.Replace_Cards(card_deck)
     elif choice == 'P':
       player.pink_cards+=1
       faceUp_cardPile.pink_cards-=1
       faceUp_cardPile.Replace_Cards(card_deck)
     elif choice == 'O':
       player.orange_cards+=1
       faceUp_cardPile.orange_cards-=1
       faceUp_cardPile.Replace_Cards(card_deck)
     elif choice == 'R':
       player.red_cards+=1
       faceUp_cardPile.red_cards-=1
       faceUp_cardPile.Replace_Cards(card_deck)
     elif choice == 'E':
       player.green_cards+=1
       faceUp_cardPile.green_cards-=1
       faceUp_cardPile.Replace_Cards(card_deck)

def Apply_Draw_Two_From_Deck(player,deck):
  deck.Draw_Card(player)

def Apply_Draw_From_Destinations(player,destination_pile,train_routes):
  drawn_destinations = []
  count = 3
  while ((count > 0)&(len(destination_pile)>0)):
    rand = random.randint(0,len(destination_pile)-1)
    drawn_destinations.append(destination_pile[rand])
    destination_pile.pop(rand)
    count-=1 
  
  kept_destinations = []
  for dest in drawn_destinations:
    if(is_Destination_Ticket_Connected(player,dest,train_routes)==True):
      kept_destinations.append(dest)
      drawn_destinations.remove(dest) 
  
  lowest_cost = float('inf')
  for dest in drawn_destinations:
    if dest.reward < lowest_cost:
      lowest_cost = dest.reward
      cheapest_destination = dest
  
  if len(kept_destinations)==0:
    kept_destinations.append(cheapest_destination)
    drawn_destinations.remove(cheapest_destination)
  
  for dest in drawn_destinations:
    destination_pile.append(dest)

  for destination in kept_destinations:
    player.destination_tickets.append(destination)

"""**Find Available Moves Functions**"""

def Find_Available_Moves(player,card_pile_faceUp,card_deck,train_routes,destinations_pile):

  available_routes_to_purchase = Get_Available_Routes(train_routes,player)
  destinations_available = Check_If_Destination_Tickets_Available(destinations_pile)
  wild_card_available = Check_For_WildCards(card_pile_faceUp)
  available_card_combinations = Get_Available_Card_Combinations(card_pile_faceUp)
  draw_from_pile = Check_Color_Cards_Remaining(card_deck)

  draw_from_destinations = True

  for destination_tix in player.destination_tickets:
    if (is_Destination_Ticket_Connected(player,destination_tix,train_routes) == False):
      draw_from_destinations = False
  
  if (draw_from_destinations==True) & (destinations_available==True):
    return [],True,False,[],False

  if(player.Cards_Remaining() < 10):
    if(wild_card_available==True)|(len(available_card_combinations)>0)|(draw_from_pile==True):
      return [],False,wild_card_available,available_card_combinations,draw_from_pile
  elif(player.Cards_Remaining() >= 10):
    return available_routes_to_purchase,False,False,[],False
  return available_routes_to_purchase,False,wild_card_available,available_card_combinations,draw_from_pile

def Get_Available_Card_Combinations(faceUp_cartPile):
  cards = []
  if faceUp_cartPile.white_cards > 0:
    for i in range(faceUp_cartPile.white_cards):
      cards.append('W')
  if faceUp_cartPile.black_cards > 0:
    for i in range(faceUp_cartPile.black_cards):
      cards.append('B')
  if faceUp_cartPile.blue_cards > 0:
    for i in range(faceUp_cartPile.blue_cards):
      cards.append('U')
  if faceUp_cartPile.yellow_cards > 0:
    for i in range(faceUp_cartPile.yellow_cards):
      cards.append('Y')
  if faceUp_cartPile.pink_cards > 0:
    for i in range(faceUp_cartPile.pink_cards):
      cards.append('P')
  if faceUp_cartPile.orange_cards > 0:
    for i in range(faceUp_cartPile.orange_cards):
      cards.append('O')
  if faceUp_cartPile.red_cards > 0:
    for i in range(faceUp_cartPile.red_cards):
      cards.append('R')
  if faceUp_cartPile.green_cards > 0:
    for i in range(faceUp_cartPile.green_cards):
      cards.append('E')

  return list(itertools.combinations(cards, 2))

def Check_Available_Colors(line):
  if line.color_extra == None:
    return line.color,'X'
  else:
    if line.owner == 0:
      return line.color,line.color_extra
    else:
      return line.owner_second_color,'X'

def Get_Available_Routes(train_routes,player):
  routes = []
  owned_routes = []

  for line in train_routes:
    if(line.owner==player.ID)|(line.owner_second==player.ID):
      owned_routes.append(line)

  for ticket in player.destination_tickets:
    for line in train_routes:
      if (line.station_one == ticket.station_one)|(line.station_one == ticket.station_two)|(line.station_two == ticket.station_one)|(line.station_two == ticket.station_two):
        if (line.owner == 0)|(line.owner_second == 0)&(line.owner != player.ID)&(line.owner_second != player.ID):
          if player.Check_Affordability(line):
            routes.append(line)

  if(len(owned_routes)== 0):
    for line in train_routes:
      if (line.owner == 0)|(line.owner_second == 0)&(line.owner != player.ID)&(line.owner_second != player.ID):
        if player.Check_Affordability(line):
          routes.append(line)
  else:
    for line in owned_routes:
      for route in train_routes:
        if(line.station_one == route.station_one)|(line.station_one == route.station_two)|(line.station_two == route.station_one)|(line.station_two == route.station_two):
          if(route.get_name() != line.get_name()):
            if((route.owner == 0)&(route.owner_second!=player.ID)):
              if((route.owner_second == 0)&(route.owner!=player.ID)):
                already_added=False
                for r in routes:
                  if(route.get_name() == r.get_name()):
                    already_added = True
                if(already_added==False):
                  if player.Check_Affordability(route):
                    routes.append(route)

  if(len(routes)== 0):
    for line in train_routes:
      if (line.owner == 0)|(line.owner_second == 0)&(line.owner != player.ID)&(line.owner_second != player.ID):
        if player.Check_Affordability(line):
          routes.append(line)

    
  return routes

def Check_For_WildCards(faceUp_cartPile):
  if faceUp_cartPile.wild_cards > 0:
    return True
  else:
    return False

def Check_Color_Cards_Remaining(deck):
  if deck.Cards_Remaining() > 0:
    return True
  else:
    return False

def Check_If_Destination_Tickets_Available(destinations_pile):
  if len(destinations_pile) > 0: 
    return True
  else: return False

"""**Calculate Game Reward Functions**"""

def count_completed_lines(player1,player2,train_routes):
  player1_score = 0
  player2_score = 0
  for route in train_routes:
    reward = 0
    cost = route.cost
    if   cost == 1: reward = 1
    elif cost == 2: reward = 2
    elif cost == 3: reward = 4
    elif cost == 4: reward = 7
    elif cost == 5: reward = 10
    elif cost == 6: reward = 15

    if (route.owner == player1.ID) | (route.owner_second == player1.ID): player1_score += reward
    if (route.owner == player2.ID) | (route.owner_second == player2.ID): player2_score += reward

  return player1_score,player2_score

def count_destination_tickets(player1,player2,train_routes):

  player1_score = 0
  player2_score = 0

  for ticket in player1.destination_tickets:
    if (is_Destination_Ticket_Connected(player1,ticket,train_routes)):
      player1_score += ticket.reward
    else:
      player1_score -= ticket.reward

  for ticket in player2.destination_tickets:
    if (is_Destination_Ticket_Connected(player2,ticket,train_routes)):
      player2_score += ticket.reward
    else:
      player2_score -= ticket.reward

  return player1_score,player2_score

def destination_tickets_completed(player1,player2,train_routes):
  player1_score = 0
  player2_score = 0

  for ticket in player1.destination_tickets:
    if (is_Destination_Ticket_Connected(player1,ticket,train_routes)):
      player1_score += 1
    else:
      player1_score -= 1

  for ticket in player2.destination_tickets:
    if (is_Destination_Ticket_Connected(player2,ticket,train_routes)):
      player2_score += 1
    else:
      player2_score -= 1

  return player1_score,player2_score

"""**Graph Search Functions**"""

def is_Destination_Ticket_Connected(player,destination_ticket,train_routes):
  starting_station = generate_station(destination_ticket.station_one,train_routes)
  visited_stations = []
  if Travers_Train_Routes_Find_Destination(player,starting_station,destination_ticket.station_two,train_routes,visited_stations):
    return True
  else: 
    return False

def Travers_Train_Routes_Find_Destination(player,station,destination,train_routes,visited_stations):

  if station.name in visited_stations:
    return False

  for line in station.connections:
    if (line.station_one == destination)|(line.station_two == destination):
      if(line.owner == player.ID)|(line.owner_second == player.ID):
        return True

  visited_stations.append(station.name)

  for line in station.connections:
    if(line.owner == player.ID):
      if(line.station_one == station.name):
        new_name = line.station_two
      else:
        new_name = line.station_one

      new_station = generate_station(new_name,train_routes)

      if (Travers_Train_Routes_Find_Destination(player,new_station,destination,train_routes,visited_stations)):
        return True

  return False

def generate_station(destination,train_routes):
  station_node = []
  for route in train_routes:
    if (route.station_one == destination) | (route.station_two == destination):
      for connecting_route in route.connections:
        if (connecting_route.station_one == destination)|(connecting_route.station_two == destination):
          station_node.append(connecting_route)
      return station(destination,station_node)

class station:
  def __init__(self,name,connections):
    self.name = name
    self.connections = connections

"""**Initializing Board Functions**"""

def set_Connecting_lines(train_routes):
  for line in train_routes:
    for x in train_routes:
      if line != x: 
        if ((line.station_one == x.station_one) | (line.station_one == x.station_two) | (line.station_two == x.station_one) | (line.station_two == x.station_two)):
          line.connections.append(x)
  
  return train_routes

def set_Initial_Route_Ownership(train_routes):
  for Line in train_routes:
    if Line.color_extra == None:
      Line.owner_second = 9
  
  return train_routes

def Generate_Train_Routes():
  Train_Routes = []
  station_01 = RailLine('Vancouver','Seattle', 1, 'G', None)
  Train_Routes.append(station_01)
  station_02 = RailLine('Vancouver','Calgary', 3, 'W', None)
  Train_Routes.append(station_02)
  station_03 = RailLine('Seattle','Calgary', 4, 'G', None)
  Train_Routes.append(station_03)
  station_04 = RailLine('Seattle','Portland', 1, 'G',None)
  Train_Routes.append(station_04)
  station_05 = RailLine('Seattle','Helena', 6, 'Y',None)
  Train_Routes.append(station_05)
  station_06 = RailLine('Calgary','Helena', 4, 'G',None)
  Train_Routes.append(station_06)
  station_07 = RailLine('Calgary','Winnipeg', 6, 'W', None)
  Train_Routes.append(station_07)
  station_08 = RailLine('Winnipeg','Helena', 4,'U', None)
  Train_Routes.append(station_08)
  station_09 = RailLine('Helena', 'Salt Lake City', 3, 'P', None)
  Train_Routes.append(station_09)
  station_10 = RailLine('Portland', 'Salt Lake City', 6, 'U', None)
  Train_Routes.append(station_10)
  station_11 = RailLine('Portland', 'San Francisco', 5, 'P', 'E')
  Train_Routes.append(station_11)
  station_12 = RailLine('San Francisco', 'Salt Lake City', 5, 'O', 'W')
  Train_Routes.append(station_12)
  station_13 = RailLine('Los Angeles', 'San Francisco', 3, 'Y', 'P')
  Train_Routes.append(station_13)
  station_14 = RailLine('Los Angeles', 'Las Vegas', 2, 'G', None)
  Train_Routes.append(station_14)
  station_15 = RailLine('Salt Lake City', 'Las Vegas', 3, 'O', None)
  Train_Routes.append(station_15)
  station_16 = RailLine('Salt Lake City', 'Denver', 3, 'R', 'Y')
  Train_Routes.append(station_16)
  station_17 = RailLine('Denver', 'Helena', 4, 'G',None)
  Train_Routes.append(station_17)
  station_18 = RailLine('Denver', 'Omaha', 4, 'P', None)
  Train_Routes.append(station_18)
  station_19 = RailLine('Helena', 'Omaha', 5, 'R', None)
  Train_Routes.append(station_19)
  station_20 = RailLine('Helena', 'Duluth', 6, 'O', None)
  Train_Routes.append(station_20)
  station_21 = RailLine('Winnipeg', 'Duluth', 4, 'B', None)
  Train_Routes.append(station_21)
  station_22 = RailLine('Winnipeg', 'Sault St. Marie', 6, 'G', None)
  Train_Routes.append(station_22)
  station_24 = RailLine('Duluth', 'Sault St. Marie', 3, 'G', None)
  Train_Routes.append(station_24)
  station_25 = RailLine('Sault St. Marie', 'Toronto', 2, 'G',None)
  Train_Routes.append(station_25)
  station_26 = RailLine('Sault St. Marie', 'Montreal', 5, 'B', None)
  Train_Routes.append(station_26)
  station_27 = RailLine('Toronto', 'Montreal', 3, 'G',None)
  Train_Routes.append(station_27)
  station_28 = RailLine('Montreal', 'Boston', 2, 'G', 'G')
  Train_Routes.append(station_28)
  station_29 = RailLine('New York', 'Montreal', 3, 'U',None)
  Train_Routes.append(station_29)
  station_30 = RailLine('New York', 'Boston', 2, 'Y', 'R')
  Train_Routes.append(station_30)
  station_31 = RailLine('Washington', 'New York', 2, 'B', 'O')
  Train_Routes.append(station_31)
  station_32 = RailLine('New York', 'Pittsburg', 2, 'W', 'E')
  Train_Routes.append(station_32)
  station_33 = RailLine('Pittsburg', 'Toronto', 2, 'G',None)
  Train_Routes.append(station_33)
  station_34 = RailLine('Toronto', 'Chicago', 4, 'W',None)
  Train_Routes.append(station_34)
  station_35 = RailLine('Toronto', 'Duluth', 6, 'P',None)
  Train_Routes.append(station_35)
  station_36 = RailLine('Duluth', 'Chicago', 3, 'R',None)
  Train_Routes.append(station_36)
  station_37 = RailLine('Chicago', 'Omaha', 4, 'U',None)
  Train_Routes.append(station_37)
  station_38 = RailLine('Denver', 'Kansas City', 4, 'B', 'O')
  Train_Routes.append(station_38)
  station_39 = RailLine('Oklahoma City', 'Denver', 4, 'R', None)
  Train_Routes.append(station_39)
  station_40 = RailLine('Denver', 'Santa Fe', 2, 'G',None)
  Train_Routes.append(station_40)
  station_41 = RailLine('Denver', 'Phoenix', 5, 'W', None)
  Train_Routes.append(station_41)
  station_42 = RailLine('Phoenix', 'Los Angeles', 3, 'G',None)
  Train_Routes.append(station_42)
  station_43 = RailLine('Los Angeles', 'El Paso', 6, 'B', None)
  Train_Routes.append(station_43)
  station_45 = RailLine('Phoenix', 'El Paso', 3, 'G', None)
  Train_Routes.append(station_45)
  station_46 = RailLine('Phoenix', 'Santa Fe', 3, 'G', None)
  Train_Routes.append(station_46)
  station_47 = RailLine('Santa Fe', 'El Paso', 2, 'G', None)
  Train_Routes.append(station_47)
  station_48 = RailLine('Santa Fe', 'Oklahoma City', 3, 'U', None)
  Train_Routes.append(station_48)
  station_49 = RailLine('Oklahoma City', 'El Paso', 5, 'Y', None)
  Train_Routes.append(station_49)
  station_50 = RailLine('Dallas', 'El Paso', 4, 'R', None)
  Train_Routes.append(station_50)
  station_51 = RailLine('Houston', 'El Paso', 6, 'E', None)
  Train_Routes.append(station_51)
  station_52 = RailLine('Dallas', 'Houston', 1, 'G', 'G')
  Train_Routes.append(station_52)
  station_53 = RailLine('Houston', 'New Orleans', 2, 'G', None)
  Train_Routes.append(station_53)
  station_54 = RailLine('Dallas', 'Little Rock', 2, 'G', None)
  Train_Routes.append(station_54)
  station_55 = RailLine('Dallas', 'Oklahoma City', 2, 'G', 'G')
  Train_Routes.append(station_55)
  station_56 = RailLine('Oklahoma City', 'Little Rock', 2, 'G',None)
  Train_Routes.append(station_56)
  station_57 = RailLine('Kansas City', 'Oklahoma City', 2, 'G', 'G')
  Train_Routes.append(station_57)
  station_58 = RailLine('Kansas City', 'St. Louis', 2, 'U', 'P')
  Train_Routes.append(station_58)
  station_59 = RailLine('Chicago', 'Kansas City', 2, 'W', 'E')
  Train_Routes.append(station_59)
  station_60 = RailLine('St. Louis', 'Pittsburg', 5, 'E', None)
  Train_Routes.append(station_60)
  station_61 = RailLine('St. Louis', 'Nashville', 2, 'G', None)
  Train_Routes.append(station_61)
  station_62 = RailLine('Little Rock', 'New Orleans', 3, 'E', None)
  Train_Routes.append(station_62)
  station_63 = RailLine('Little Rock', 'Nashville', 3, 'W', None)
  Train_Routes.append(station_63)
  station_64 = RailLine('Nashville', 'Raleigh', 3, 'B', None)
  Train_Routes.append(station_64)
  station_65 = RailLine('Nashville', 'Pittsburg', 4, 'Y',None)
  Train_Routes.append(station_65)
  station_66 = RailLine('Chicago', 'Pittsburg', 3, 'O', 'B')
  Train_Routes.append(station_66)
  station_67 = RailLine('Pittsburg', 'Washington', 2, 'G', None)
  Train_Routes.append(station_67)
  station_68 = RailLine('Pittsburg', 'Raleigh', 2, 'G', None)
  Train_Routes.append(station_68)
  station_69 = RailLine('Raleigh', 'Washington', 2, 'G', 'G')
  Train_Routes.append(station_69)
  station_70 = RailLine('Raleigh', 'Atlanta', 2, 'G', 'G')
  Train_Routes.append(station_70)
  station_71 = RailLine('Raleigh', 'Charleston', 2, 'G', None)
  Train_Routes.append(station_71)
  station_72 = RailLine('Atlanta', 'Charleston', 2, 'G', None)
  Train_Routes.append(station_72)
  station_73 = RailLine('Nashville', 'Atlanta', 1, 'G', None)
  Train_Routes.append(station_73)
  station_74 = RailLine('St. Louis', 'Little Rock', 2, 'G', None)
  Train_Routes.append(station_74)
  station_75 = RailLine('Atlanta', 'New Orleans', 4, 'Y', 'O')
  Train_Routes.append(station_75)
  station_76 = RailLine('Atlanta', 'Miami', 5, 'U', None)
  Train_Routes.append(station_76)
  station_77 = RailLine('Charleston', 'Miami', 4, 'P', None)
  Train_Routes.append(station_77)
  station_78 = RailLine('Miami', 'New Orleans', 6, 'R', None)
  Train_Routes.append(station_78)
  station_79 = RailLine('Omaha', 'Kansas City', 1, 'G', 'G')
  Train_Routes.append(station_79)
  station_80 = RailLine('Omaha', 'Duluth', 2, 'G', 'G')
  Train_Routes.append(station_80)

  Train_Routes = set_Connecting_lines(Train_Routes)
  Train_Routes = set_Initial_Route_Ownership(Train_Routes)
  return Train_Routes

def Generate_Destination_Tickets():
  Destination_Tickets_Pile = []
  destination_ticket_01 = Destintation_Ticket('Boston',	'Miami',	12)
  Destination_Tickets_Pile.append(destination_ticket_01)
  destination_ticket_02 = Destintation_Ticket('Calgary',	'Phoenix',	13)
  Destination_Tickets_Pile.append(destination_ticket_02)
  destination_ticket_03 = Destintation_Ticket('Calgary',	'Salt Lake City',	7)
  Destination_Tickets_Pile.append(destination_ticket_03)
  destination_ticket_04 = Destintation_Ticket('Chicago',	'New Orleans',	7)
  Destination_Tickets_Pile.append(destination_ticket_04)
  destination_ticket_05 = Destintation_Ticket('Chicago',	'Santa Fe',	9)
  Destination_Tickets_Pile.append(destination_ticket_05)
  destination_ticket_06 = Destintation_Ticket('Dallas',	'New York',	11)
  Destination_Tickets_Pile.append(destination_ticket_06)
  destination_ticket_07 = Destintation_Ticket('Denver',	'El Paso',	4)
  Destination_Tickets_Pile.append(destination_ticket_07)
  destination_ticket_08 = Destintation_Ticket('Denver',	'Pittsburgh',	11)
  Destination_Tickets_Pile.append(destination_ticket_08)
  destination_ticket_09 = Destintation_Ticket('Duluth',	'El Paso',	10)
  Destination_Tickets_Pile.append(destination_ticket_09)
  destination_ticket_10 = Destintation_Ticket('Duluth',	'Houston',	8)
  Destination_Tickets_Pile.append(destination_ticket_10)
  destination_ticket_11 = Destintation_Ticket('Helena',	'Los Angeles',	8)
  Destination_Tickets_Pile.append(destination_ticket_11)
  destination_ticket_12 = Destintation_Ticket('Kansas City',	'Houston',	5)
  Destination_Tickets_Pile.append(destination_ticket_12)
  destination_ticket_13 = Destintation_Ticket('Los Angeles',	'Chicago',	16)
  Destination_Tickets_Pile.append(destination_ticket_13)
  destination_ticket_14 = Destintation_Ticket('Los Angeles',	'Miami',	20)
  Destination_Tickets_Pile.append(destination_ticket_14)
  destination_ticket_15 = Destintation_Ticket('Los Angeles',	'New York',	21)
  Destination_Tickets_Pile.append(destination_ticket_15)
  destination_ticket_16 = Destintation_Ticket('Montreal',	'Atlanta',	9)
  Destination_Tickets_Pile.append(destination_ticket_16)
  destination_ticket_17 = Destintation_Ticket('Montreal',	'New Orleans',	13)
  Destination_Tickets_Pile.append(destination_ticket_17)
  destination_ticket_18 = Destintation_Ticket('New York',	'Atlanta',	6)
  Destination_Tickets_Pile.append(destination_ticket_18)
  destination_ticket_19 = Destintation_Ticket('Portland',	'Nashville',	17)
  Destination_Tickets_Pile.append(destination_ticket_19)
  destination_ticket_20 = Destintation_Ticket('Portland',	'Phoenix',	11)
  Destination_Tickets_Pile.append(destination_ticket_20)
  destination_ticket_21 = Destintation_Ticket('San Francisco',	'Atlanta',	17)
  Destination_Tickets_Pile.append(destination_ticket_21)
  destination_ticket_22 = Destintation_Ticket('Sault St. Marie',	'Nashville',	8)
  Destination_Tickets_Pile.append(destination_ticket_22)
  destination_ticket_23 = Destintation_Ticket('Sault St. Marie',	'Oklahoma City',	9)
  Destination_Tickets_Pile.append(destination_ticket_23)
  destination_ticket_24 = Destintation_Ticket('Seattle',	'Los Angeles',	9)
  Destination_Tickets_Pile.append(destination_ticket_24)
  destination_ticket_25 = Destintation_Ticket('Seattle',	'New York',	22)
  Destination_Tickets_Pile.append(destination_ticket_25)
  destination_ticket_26 = Destintation_Ticket('Toronto',	'Miami',	10)
  Destination_Tickets_Pile.append(destination_ticket_26)
  destination_ticket_27 = Destintation_Ticket('Vancouver',	'Montreal',	20)
  Destination_Tickets_Pile.append(destination_ticket_27)
  destination_ticket_28 = Destintation_Ticket('Vancouver',	'Santa Fe',	13)
  Destination_Tickets_Pile.append(destination_ticket_28)
  destination_ticket_29 = Destintation_Ticket('Winnipeg',	'Houston',	12)
  Destination_Tickets_Pile.append(destination_ticket_29)
  destination_ticket_30 = Destintation_Ticket('Winnipeg',	'Little Rock',	11)
  Destination_Tickets_Pile.append(destination_ticket_30)
  return Destination_Tickets_Pile

"""**Monte Carlo Tree Search**"""

def Monte_Carlo_Tree_Search(game_node,iter):
  iterations = iter
  starting_node = cPickle.loads(cPickle.dumps(game_node, -1))
  starting_node.visits=1
  starting_node.child_nodes.clear()
  available_routes_to_purchase, destinations_available, wild_card_available, available_card_combinations, draw_from_pile = Find_Available_Moves(starting_node.player_1,starting_node.face_up_cards,starting_node.deck,starting_node.train_routes,starting_node.destination_ticket_deck)
  #while(len(available_routes_to_purchase)>8):
  #  available_routes_to_purchase.remove(random.choice(available_routes_to_purchase))
  #while(len(available_card_combinations)>8):
  #    available_card_combinations.remove(random.choice(available_card_combinations))
  starting_node.child_nodes = generate_children_nodes(starting_node,available_routes_to_purchase,destinations_available, wild_card_available, available_card_combinations,draw_from_pile,True)

  if(len(available_routes_to_purchase)==0)&(destinations_available==False):
    iterations = 21

  if(len(starting_node.child_nodes) == 1):
    return starting_node.child_nodes[0]
  current_node = starting_node
  print("Starting Node Generated ", len(starting_node.child_nodes), "Child Nodes")
  #Generate All Possible Moves
  #Create New Child for each Move
  #Set Current Node to First Child
  player_turn = True
  while(iterations>0):
    iterations-=1
    print("Start:",iterations, " Iterations Remaining...")
    if (len(current_node.child_nodes) == 0):
      print("Found Leaf Node")
      if current_node.visits == 0:
        print("First Time Visiting")
        print("Running Simulation")
        game_simulation = cPickle.loads(cPickle.dumps(current_node, -1))
        p1_score,p2_score = play_random_simulation(game_simulation)
        win = winner(p1_score,p2_score)
        print("Finish Simulation", win)
        Back_Propogation(current_node,win)
        current_node.visits+=1
        current_node = starting_node 
      else:
        print("Creating New Child Nodes")
        if player_turn == True:
          available_routes_to_purchase1, destinations_available1, wild_card_available1, available_card_combinations1, draw_from_pile1 = Find_Available_Moves(current_node.player_1,current_node.face_up_cards,current_node.deck,current_node.train_routes,current_node.destination_ticket_deck)
          while(len(available_routes_to_purchase1)>8):
            available_routes_to_purchase1.remove(random.choice(available_routes_to_purchase1))   
          while(len(available_card_combinations1)>8):
            available_card_combinations1.remove(random.choice(available_card_combinations1))
          current_node.child_nodes = generate_children_nodes(current_node,available_routes_to_purchase1,destinations_available1, wild_card_available1, available_card_combinations1,draw_from_pile1,player_turn)
        else:
          available_routes_to_purchase1, destinations_available1, wild_card_available1, available_card_combinations1, draw_from_pile1 = Find_Available_Moves(current_node.player_2,current_node.face_up_cards,current_node.deck,current_node.train_routes,current_node.destination_ticket_deck)
          while(len(available_routes_to_purchase1)>8):
            available_routes_to_purchase1.remove(random.choice(available_routes_to_purchase1))
          while(len(available_card_combinations1)>8):
            available_card_combinations1.remove(random.choice(available_card_combinations1))          
          current_node.child_nodes = generate_children_nodes(current_node,available_routes_to_purchase1,destinations_available1, wild_card_available1, available_card_combinations1,draw_from_pile1,player_turn)
        print("Generated ",len(current_node.child_nodes)," Child Nodes")                                         
        #Generate All Possible Moves
        #Create New Child Nodes For Each Move
        if len(current_node.child_nodes) > 0:
          current_node = current_node.child_nodes[0]
          current_node.parent_node.visits+=1
        #Play Random Simulation
        print("Running Simulation")
        game_simulation = cPickle.loads(cPickle.dumps(current_node, -1))
        p1_score,p2_score = play_random_simulation(game_simulation)
        win = winner(p1_score,p2_score)
        print("Finish Simulation", win)
        Back_Propogation(current_node,win)
        current_node.visits+=1
        current_node = starting_node  
    else:
      print("Selecting Best Node")
      #Current_Node = Node Which Maximizes UCB1
      best_score = float('-inf')
      next_node = current_node.child_nodes[0]
      for child in current_node.child_nodes:
        ucb1 = Upper_Confidence_Bound1(child)
        if ucb1 > best_score:
          best_score = ucb1
          next_node = child 
      current_node = next_node
      current_node.parent_node.visits+=1
      

    if player_turn == True: player_turn = False
    else: player_turn = True  

  best_score = float('-inf')
  best_move = starting_node.child_nodes[0]
  for child in starting_node.child_nodes:
    score = child.wins
    print("move score: ", score, " move visits: ",child.visits)
    if score > best_score:
      best_score = score
      best_move = child
  #best_move.Print_Game_Info()
  return best_move

def Random_Move_Player(game_node):
  move_options = 0
  available_routes_to_purchase, destinations_available, wild_card_available, available_card_combinations, draw_from_pile = Find_Available_Moves(game_node.player_2,game_node.face_up_cards,game_node.deck,game_node.train_routes,game_node.destination_ticket_deck)
  made_move = False
  while(made_move == False):
    rand = random.randint(0,4)
    if rand == 0:
      if(len(available_routes_to_purchase)>0):
        rand = random.randint(0,len(available_routes_to_purchase)-1)
        Apply_Build_Line(game_node.player_2,available_routes_to_purchase[rand],game_node.deck)
        made_move = True
    elif rand == 1:
      if destinations_available == True:
        Apply_Draw_From_Destinations(game_node.player_2,game_node.destination_ticket_deck,game_node.train_routes)
        made_move = True
    elif rand == 2:
      if wild_card_available == True:
        Apply_Draw_Wildcard(game_node.player_2,game_node.face_up_cards,game_node.deck)
        made_move = True
    elif rand == 3:
      if(len(available_card_combinations)>0):
        rand = random.randint(0,len(available_card_combinations)-1)
        Apply_Pick_From_FaceUp_Pile(game_node.player_2,available_card_combinations[rand],game_node.face_up_cards,game_node.deck)
        made_move = True
    elif rand == 4:
      if draw_from_pile == True:
        Apply_Draw_Two_From_Deck(game_node.player_2,game_node.deck)
        made_move = True
  return game_node

def Upper_Confidence_Bound1(game_node):
  if game_node.visits == 0:
    return float('inf')
  Vi = game_node.wins/game_node.visits
  UCB1 = Vi + 2*math.sqrt(math.log(game_node.parent_node.visits)/game_node.visits)
  return UCB1

def winner(p1_score,p2_score):
  if p1_score > p2_score:
    return True
  else: return False

def Back_Propogation(start_node,win):
  current_node = start_node
  score = 0
  if win == True:
    score = 1
  while(current_node.parent_node != None):
    current_node.wins+=score
    current_node = current_node.parent_node

def Back_Propogation_Alt(start_node,scored):
  current_node = start_node
  score = 0
  if score > 0:
    score = scored
  while(current_node.parent_node != None):
    current_node.wins+=score
    current_node = current_node.parent_node

def play_random_simulation(game_node):
  player_turn = True
  while((game_node.player_1.train_carts > 2)&(game_node.player_2.train_carts > 2)):
    if(player_turn == True):
      move_options = 0
      available_routes_to_purchase, destinations_available, wild_card_available, available_card_combinations, draw_from_pile = Find_Available_Moves(game_node.player_1,game_node.face_up_cards,game_node.deck,game_node.train_routes,game_node.destination_ticket_deck)
      made_move = False
      while(made_move == False):
        rand = random.randint(0,4)
        if rand == 0:
          if(len(available_routes_to_purchase)>0):
            rand = random.randint(0,len(available_routes_to_purchase)-1)
            Apply_Build_Line(game_node.player_1,available_routes_to_purchase[rand],game_node.deck)
            made_move = True
        elif rand == 1:
          if destinations_available == True:
            Apply_Draw_From_Destinations(game_node.player_1,game_node.destination_ticket_deck,game_node.train_routes)
            made_move = True
        elif rand == 2:
          if wild_card_available == True:
            Apply_Draw_Wildcard(game_node.player_1,game_node.face_up_cards,game_node.deck)
            made_move = True
        elif rand == 3:
          if(len(available_card_combinations)>0):
            rand = random.randint(0,len(available_card_combinations)-1)
            Apply_Pick_From_FaceUp_Pile(game_node.player_1,available_card_combinations[rand],game_node.face_up_cards,game_node.deck)
            made_move = True
        elif rand == 4:
          if draw_from_pile == True:
            Apply_Draw_Two_From_Deck(game_node.player_1,game_node.deck)
            made_move = True
      player_turn = False

    elif(player_turn == False):
      move_options = 0
      available_routes_to_purchase, destinations_available, wild_card_available, available_card_combinations, draw_from_pile = Find_Available_Moves(game_node.player_2,game_node.face_up_cards,game_node.deck,game_node.train_routes,game_node.destination_ticket_deck)
      made_move = False
      while(made_move == False):
        rand = random.randint(0,4)
        if rand == 0:
          if(len(available_routes_to_purchase)>0):
            rand = random.randint(0,len(available_routes_to_purchase)-1)
            Apply_Build_Line(game_node.player_2,available_routes_to_purchase[rand],game_node.deck)
            made_move = True
        elif rand == 1:
          if destinations_available == True:
            Apply_Draw_From_Destinations(game_node.player_2,game_node.destination_ticket_deck,game_node.train_routes)
            made_move = True
        elif rand == 2:
          if wild_card_available == True:
            Apply_Draw_Wildcard(game_node.player_2,game_node.face_up_cards,game_node.deck)
            made_move = True
        elif rand == 3:
          if(len(available_card_combinations)>0):
            rand = random.randint(0,len(available_card_combinations)-1)
            Apply_Pick_From_FaceUp_Pile(game_node.player_2,available_card_combinations[rand],game_node.face_up_cards,game_node.deck)
            made_move = True
        elif rand == 4:
          if draw_from_pile == True:
            Apply_Draw_Two_From_Deck(game_node.player_2,game_node.deck)
            made_move = True
      player_turn = True 

  p1_score_alpha,p2_score_alpha = count_completed_lines(game_node.player_1,game_node.player_2,game_node.train_routes)
  p1_score_beta, p2_score_beta = count_destination_tickets(game_node.player_1,game_node.player_2,game_node.train_routes)
  p1_score_total = p1_score_alpha + p1_score_beta
  p2_score_total = p2_score_alpha + p2_score_beta
  p1_alt_score,p2_alt_score = destination_tickets_completed(game_node.player_1,game_node.player_2,game_node.train_routes)

  return p1_score_total,p2_score_total

def generate_children_nodes(game_node,available_routes,destinations_available, wild_card_available, available_card_combinations, draw_from_pile,playing):
  child_nodes = []
  game_state = cPickle.dumps(game_node,-1)
  if playing == True:
    for route in available_routes:
      new_game_node = cPickle.loads(game_state)
      #new_game_node = copy.copy(game_node)
      new_game_node.parent_node = game_node
      new_game_node.visits = 0
      new_game_node.wins = 0
      for line in new_game_node.train_routes:
        if line.get_name() == route.get_name():
          this_line = line
      Apply_Build_Line(new_game_node.player_1,this_line,new_game_node.deck)
      child_nodes.append(new_game_node)
  
    if destinations_available == True:
      new_game_node = cPickle.loads(game_state)
      #new_game_node = copy.copy(game_node)
      new_game_node.parent_node = game_node
      new_game_node.visits = 0
      new_game_node.wins = 0
      Apply_Draw_From_Destinations(new_game_node.player_1,new_game_node.destination_ticket_deck,new_game_node.train_routes)
      child_nodes.append(new_game_node)
  
    if wild_card_available == True:
      new_game_node = cPickle.loads(game_state)
      #new_game_node = copy.copy(game_node)
      new_game_node.parent_node = game_node
      new_game_node.visits = 0
      new_game_node.wins = 0
      Apply_Draw_Wildcard(new_game_node.player_1,new_game_node.face_up_cards,new_game_node.deck)
      child_nodes.append(new_game_node)
  
    for card_combo in available_card_combinations:
      new_game_node = cPickle.loads(game_state)
      #new_game_node = copy.copy(game_node)
      new_game_node.parent_node = game_node
      new_game_node.visits = 0
      new_game_node.wins = 0
      Apply_Pick_From_FaceUp_Pile(new_game_node.player_1,card_combo,new_game_node.face_up_cards,new_game_node.deck)
      child_nodes.append(new_game_node)
  
    if draw_from_pile == True:
      new_game_node = cPickle.loads(game_state)
      #new_game_node = copy.copy(game_node)
      new_game_node.parent_node = game_node
      new_game_node.visits = 0
      new_game_node.wins = 0
      Apply_Draw_Two_From_Deck(new_game_node.player_1,new_game_node.deck)
      child_nodes.append(new_game_node)
  else:
    for route in available_routes:
      new_game_node = cPickle.loads(game_state)
      #new_game_node = copy.copy(game_node)
      new_game_node.parent_node = game_node
      new_game_node.visits = 0
      new_game_node.wins = 0
      for line in new_game_node.train_routes:
        if line.get_name() == route.get_name():
          this_line = line
      Apply_Build_Line(new_game_node.player_2,this_line,new_game_node.deck)
      child_nodes.append(new_game_node)
  
    if destinations_available == True:
      new_game_node = cPickle.loads(game_state)
      #new_game_node = copy.copy(game_node)
      new_game_node.parent_node = game_node
      new_game_node.visits = 0
      new_game_node.wins = 0
      Apply_Draw_From_Destinations(new_game_node.player_2,new_game_node.destination_ticket_deck,new_game_node.train_routes)
      child_nodes.append(new_game_node)
  
    if wild_card_available == True:
      new_game_node = cPickle.loads(game_state)
      #new_game_node = copy.copy(game_node)
      new_game_node.parent_node = game_node
      new_game_node.visits = 0
      new_game_node.wins = 0
      Apply_Draw_Wildcard(new_game_node.player_2,new_game_node.face_up_cards,new_game_node.deck)
      child_nodes.append(new_game_node)
  
    for card_combo in available_card_combinations:
      new_game_node = cPickle.loads(game_state)
      #new_game_node = copy.copy(game_node)
      new_game_node.parent_node = game_node
      new_game_node.visits = 0
      new_game_node.wins = 0
      Apply_Pick_From_FaceUp_Pile(new_game_node.player_2,card_combo,new_game_node.face_up_cards,new_game_node.deck)
      child_nodes.append(new_game_node)
  
    if draw_from_pile == True:
      new_game_node = cPickle.loads(game_state)
      #new_game_node = copy.copy(game_node)
      new_game_node.parent_node = game_node
      new_game_node.visits = 0
      new_game_node.wins = 0
      Apply_Draw_Two_From_Deck(new_game_node.player_2,new_game_node.deck)
      child_nodes.append(new_game_node) 
  return child_nodes

"""**Game Set Up/ Simulations**"""

def Play_Ticket_To_Ride():
  #with open('/content/drive/MyDrive/Ticket_To_Ride/saved-game.pickle', 'rb') as handle:
  #  Game = pickle.load(handle)
  Game = Game_Setup()
  Game.Print_Game_Info()
  Counter = 0
  Iterations = 50
  random.seed()
  while((Game.player_1.train_carts > 2)&(Game.player_2.train_carts > 2)):
    Counter+=1
    print("ROUND #",Counter)
    print("Player 1 Turn: ")
    Game = Monte_Carlo_Tree_Search(Game,Iterations)
    Game.Print_Game_Info()
    Game = Game_Positions_Swap(Game)
    print("Player 2 Turn")
    Game = Monte_Carlo_Tree_Search(Game,Iterations)
    Game = Game_Positions_Swap(Game)
    Game.Print_Game_Info()
    #with open('/content/drive/MyDrive/Ticket_To_Ride/saved-game.pickle', 'wb') as handle:
    #  pickle.dump(Game, handle, protocol=pickle.HIGHEST_PROTOCOL)
    #Iterations+=5
    #if(Iterations>50):
    #  Iterations = 50
  
  p1_score_alpha,p2_score_alpha = count_completed_lines(Game.player_1,Game.player_2,Game.train_routes)
  p1_score_beta, p2_score_beta = count_destination_tickets(Game.player_1,Game.player_2,Game.train_routes)
  p1_score_total = p1_score_alpha + p1_score_beta
  p2_score_total = p2_score_alpha + p2_score_beta

  print("GAME RESULTS:")
  print("Player 1 Score: (",p1_score_total,")")
  print("Player 2 Score: (",p2_score_total,")")

#with open('/content/drive/MyDrive/Ticket_To_Ride/saved-game.pickle', 'rb') as handle:
#    b = pickle.load(handle)

def Game_Setup():
  player1 = Player(1)
  player2 = Player(2)
  game_deck = Train_Card_Deck()
  face_up_cards = FaceUp_Card_Pile()
  face_up_cards.wild_cards=1
  face_up_cards.white_cards=1
  face_up_cards.red_cards=1
  face_up_cards.black_cards=2
  player1.white_cards=2
  player1.blue_cards=2
  player1.wild_cards=1
  player2.white_cards=2
  player2.blue_cards=2
  player2.wild_cards=1
  Train_Routes = Generate_Train_Routes()
  Destination_Tickets_Pile = Generate_Destination_Tickets()
  player1.destination_tickets.append(Destination_Tickets_Pile[0])
  Destination_Tickets_Pile.pop(0)
  player1.destination_tickets.append(Destination_Tickets_Pile[0])
  Destination_Tickets_Pile.pop(0)
  player2.destination_tickets.append(Destination_Tickets_Pile[0])
  Destination_Tickets_Pile.pop(0)
  player2.destination_tickets.append(Destination_Tickets_Pile[0])
  Destination_Tickets_Pile.pop(0)
  return game_node_class(player1,player2,Train_Routes,face_up_cards,game_deck,Destination_Tickets_Pile,None)

"""# **PLAY GAME**"""

Play_Ticket_To_Ride()